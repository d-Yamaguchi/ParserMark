// arith.cc
// *** DO NOT EDIT BY HAND ***
// automatically generated by gramanl, from arith.gr

// GLR source location information is enabled

#include "arith.h"     // Arith
#include "parsetables.h" // ParseTables
#include "srcloc.h"      // SourceLoc

#include <assert.h>      // assert
#include <iostream>    // std::cout
#include <stdlib.h>      // abort

static char const *termNames[] = {
  "TOK_EOF",  // 0
  "TOK_NUMBER",  // 1
  "TOK_PLUS",  // 2
  "TOK_MINUS",  // 3
  "TOK_TIMES",  // 4
  "TOK_DIVIDE",  // 5
  "TOK_LPAREN",  // 6
  "TOK_RPAREN",  // 7
};

string Arith::terminalDescription(int termId, SemanticValue sval)
{
  return stringc << termNames[termId]
                 << "(" << (sval % 100000) << ")";
}


static char const *nontermNames[] = {
  "empty",  // 0
  "__EarlyStartSymbol",  // 1
  "Exp",  // 2
  "ParenthesizedExp",  // 3
};

string Arith::nonterminalDescription(int nontermId, SemanticValue sval)
{
  return stringc << nontermNames[nontermId]
                 << "(" << (sval % 100000) << ")";
}


char const *Arith::terminalName(int termId)
{
  return termNames[termId];
}

char const *Arith::nonterminalName(int nontermId)
{
  return nontermNames[nontermId];
}

// ------------------- actions ------------------
// [0] __EarlyStartSymbol[int] -> top:Exp TOK_EOF
inline int Arith::action0___EarlyStartSymbol(SourceLoc loc, int top)
#line 1 "<init>"
{ return top;  }
#line 63 "arith.cc"

// [1] Exp[int] -> e1:Exp + e2:Exp %prec(10)
inline int Arith::action1_Exp(SourceLoc loc, int e1, int e2)
#line 106 "arith.gr"
{ return e1 + e2;  }
#line 69 "arith.cc"

// [2] Exp[int] -> e1:Exp - e2:Exp %prec(10)
inline int Arith::action2_Exp(SourceLoc loc, int e1, int e2)
#line 108 "arith.gr"
{ return e1 - e2;  }
#line 75 "arith.cc"

// [3] Exp[int] -> e1:Exp * e2:Exp %prec(20)
inline int Arith::action3_Exp(SourceLoc loc, int e1, int e2)
#line 109 "arith.gr"
{ return e1 * e2;  }
#line 81 "arith.cc"

// [4] Exp[int] -> e1:Exp / e2:Exp %prec(20)
inline int Arith::action4_Exp(SourceLoc loc, int e1, int e2)
#line 110 "arith.gr"
{ return e1 / e2;  }
#line 87 "arith.cc"

// [5] Exp[int] -> n:TOK_NUMBER
inline int Arith::action5_Exp(SourceLoc loc, int n)
#line 111 "arith.gr"
{ return n;  }
#line 93 "arith.cc"

// [6] Exp[int] -> p:ParenthesizedExp
inline int Arith::action6_Exp(SourceLoc loc, int p)
#line 112 "arith.gr"
{ return p;  }
#line 99 "arith.cc"

// [7] ParenthesizedExp[int] -> ( e:Exp )
inline int Arith::action7_ParenthesizedExp(SourceLoc loc, int e)
#line 118 "arith.gr"
{ return e;  }
#line 105 "arith.cc"


/*static*/ SemanticValue Arith::doReductionAction(
  Arith *ths,
  int productionId, SemanticValue const *semanticValues,
  SourceLoc loc)
{
  switch (productionId) {
    case 0:
      return (SemanticValue)(ths->action0___EarlyStartSymbol(loc, (int)(semanticValues[0])));
    case 1:
      return (SemanticValue)(ths->action1_Exp(loc, (int)(semanticValues[0]), (int)(semanticValues[2])));
    case 2:
      return (SemanticValue)(ths->action2_Exp(loc, (int)(semanticValues[0]), (int)(semanticValues[2])));
    case 3:
      return (SemanticValue)(ths->action3_Exp(loc, (int)(semanticValues[0]), (int)(semanticValues[2])));
    case 4:
      return (SemanticValue)(ths->action4_Exp(loc, (int)(semanticValues[0]), (int)(semanticValues[2])));
    case 5:
      return (SemanticValue)(ths->action5_Exp(loc, (int)(semanticValues[0])));
    case 6:
      return (SemanticValue)(ths->action6_Exp(loc, (int)(semanticValues[0])));
    case 7:
      return (SemanticValue)(ths->action7_ParenthesizedExp(loc, (int)(semanticValues[1])));
    default:
      assert(!"invalid production code");
      return (SemanticValue)0;   // silence warning
  }
}

UserActions::ReductionActionFunc Arith::getReductionAction()
{
  return (ReductionActionFunc)&Arith::doReductionAction;
}


// ---------------- dup/del/merge/keep nonterminals ---------------

SemanticValue Arith::duplicateNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    default:
      return (SemanticValue)0;
  }
}

void Arith::deallocateNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    default:
      std::cout << "WARNING: there is no action to deallocate nonterm "
           << nontermNames[nontermId] << std::endl;
  }
}

SemanticValue Arith::mergeAlternativeParses(int nontermId, SemanticValue left,
                                           SemanticValue right,  SourceLoc loc)
{
  switch (nontermId) {
    default:
      std::cout << toString(loc) 
           << ": WARNING: there is no action to merge nonterm "
           << nontermNames[nontermId] << std::endl;
      return left;
  }
}

bool Arith::keepNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    default:
      return true;
  }
}


// ---------------- dup/del/classify terminals ---------------
SemanticValue Arith::duplicateTerminalValue(int termId, SemanticValue sval)
{
  switch (termId) {
    case 0:
      return sval;
    case 2:
      return sval;
    case 3:
      return sval;
    case 4:
      return sval;
    case 5:
      return sval;
    case 6:
      return sval;
    case 7:
      return sval;
    default:
      return (SemanticValue)0;
  }
}

void Arith::deallocateTerminalValue(int termId, SemanticValue sval)
{
  switch (termId) {
    case 0:
      break;
    case 2:
      break;
    case 3:
      break;
    case 4:
      break;
    case 5:
      break;
    case 6:
      break;
    case 7:
      break;
    default:
      std::cout << "WARNING: there is no action to deallocate terminal "
           << termNames[termId] << std::endl;
  }
}

/*static*/ int Arith::reclassifyToken(Arith *ths, int oldTokenType, SemanticValue sval)
{
  switch (oldTokenType) {
    default:
      return oldTokenType;
  }
}

UserActions::ReclassifyFunc Arith::getReclassifier()
{
  return (ReclassifyFunc)&Arith::reclassifyToken;
}


// this makes a ParseTables from some literal data;
// the code is written by ParseTables::emitConstructionCode()
// in parsetables.cc
class Arith_ParseTables : public ParseTables {
public:
  Arith_ParseTables();
};

Arith_ParseTables::Arith_ParseTables()
  : ParseTables(false /*owning*/)
{
  numTerms = 8;
  numNonterms = 4;
  numStates = 16;
  numProds = 8;
  actionCols = 8;
  actionRows = 16;
  gotoCols = 4;
  gotoRows = 16;
  ambigTableSize = 0;
  startState = (StateId)0;
  finalProductionIndex = 0;
  bigProductionListSize = 0;
  errorBitsRowSize = 4;
  uniqueErrorRows = 0;

  // storage size: 256 bytes
  // rows: 16  cols: 8
  static ActionEntry const actionTable_static[128] = {
    /* 0*/ 0, 3, 0, 0, 0, 0, 8, 0, 
    /* 1*/ 0, 0, 0, 0, 0, 0, 0, 0, 
    /* 2*/ -6, 0, -6, -6, -6, -6, 0, -6, 
    /* 3*/ 0, 3, 0, 0, 0, 0, 8, 0, 
    /* 4*/ 0, 3, 0, 0, 0, 0, 8, 0, 
    /* 5*/ 0, 3, 0, 0, 0, 0, 8, 0, 
    /* 6*/ 0, 3, 0, 0, 0, 0, 8, 0, 
    /* 7*/ 0, 3, 0, 0, 0, 0, 8, 0, 
    /* 8*/ -8, 0, -8, -8, -8, -8, 0, -8, 
    /* 9*/ 2, 0, 4, 5, 6, 7, 0, 0, 
    /*10*/ 0, 0, 4, 5, 6, 7, 0, 9, 
    /*11*/ -2, 0, -2, -2, 6, 7, 0, -2, 
    /*12*/ -3, 0, -3, -3, 6, 7, 0, -3, 
    /*13*/ -4, 0, -4, -4, -4, -4, 0, -4, 
    /*14*/ -5, 0, -5, -5, -5, -5, 0, -5, 
    /*15*/ -7, 0, -7, -7, -7, -7, 0, -7, 
  };
  actionTable = const_cast<ActionEntry*>(actionTable_static);

  // storage size: 128 bytes
  // rows: 16  cols: 4
  static GotoEntry const gotoTable_static[64] = {
    /* 0*/ 65535, 65535, 9, 15, 
    /* 1*/ 65535, 65535, 65535, 65535, 
    /* 2*/ 65535, 65535, 65535, 65535, 
    /* 3*/ 65535, 65535, 11, 15, 
    /* 4*/ 65535, 65535, 12, 15, 
    /* 5*/ 65535, 65535, 13, 15, 
    /* 6*/ 65535, 65535, 14, 15, 
    /* 7*/ 65535, 65535, 10, 15, 
    /* 8*/ 65535, 65535, 65535, 65535, 
    /* 9*/ 65535, 65535, 65535, 65535, 
    /*10*/ 65535, 65535, 65535, 65535, 
    /*11*/ 65535, 65535, 65535, 65535, 
    /*12*/ 65535, 65535, 65535, 65535, 
    /*13*/ 65535, 65535, 65535, 65535, 
    /*14*/ 65535, 65535, 65535, 65535, 
    /*15*/ 65535, 65535, 65535, 65535, 
  };
  gotoTable = const_cast<GotoEntry*>(gotoTable_static);

  static ParseTables::ProdInfo const prodInfo_static[8] = {
    /*0*/ {2,1}, {3,2}, {3,2}, {3,2}, {3,2}, {1,2}, {1,2}, {3,3}, 
  };
  prodInfo = const_cast<ParseTables::ProdInfo*>(prodInfo_static);

  static SymbolId const stateSymbol_static[16] = {
    /*0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, -3, -3, -3, -3, -3, -3, -4, 
  };
  stateSymbol = const_cast<SymbolId*>(stateSymbol_static);

  ActionEntry *ambigTable_static = NULL;
  ambigTable = const_cast<ActionEntry*>(ambigTable_static);

  static NtIndex const nontermOrder_static[4] = {
    /*0*/ 3, 2, 1, 0, 
  };
  nontermOrder = const_cast<NtIndex*>(nontermOrder_static);

  ErrorBitsEntry *errorBits_static = NULL;
  errorBits = const_cast<ErrorBitsEntry*>(errorBits_static);

  errorBitsPointers = NULL;

  TermIndex *actionIndexMap_static = NULL;
  actionIndexMap = const_cast<TermIndex*>(actionIndexMap_static);

  actionRowPointers = NULL;

  NtIndex *gotoIndexMap_static = NULL;
  gotoIndexMap = const_cast<NtIndex*>(gotoIndexMap_static);

  gotoRowPointers = NULL;

  firstWithTerminal = NULL;
  firstWithNonterminal = NULL;
  bigProductionList = NULL;
  productionsForState = NULL;
  ambigStateTable = NULL;
}


ParseTables *Arith::makeTables()
{
  return new Arith_ParseTables;
}

